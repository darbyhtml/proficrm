# Архитектура CRMProfiDialer (Android)

Этот документ описывает архитектуру Android‑приложения CRMProfiDialer: слои, основные компоненты, фоновую службу и общий поток обработки команд звонков.

---

## Общее устройство приложения

- **Платформа**: Android, минимум одна `app`‑модуль.
- **Подход**: упрощённый Clean Architecture.
- **Главная идея**: приложение — «тонкий» клиент, который:
  - принимает команды на звонки из CRM (long‑poll / adaptive polling),
  - инициирует звонок через системную звонилку,
  - отслеживает результат через `CallLog`,
  - отправляет результат и телеметрию обратно в CRM.

### Слои

- **UI слой (presentation)**  
  - `MainActivity` с **Bottom Navigation**.  
  - Фрагменты: `HomeFragment`, `DialerFragment`, `HistoryFragment`, `SettingsFragment`.  
  - Экраны логина и онбординга: `LoginActivity`, `QRLoginActivity`, `OnboardingActivity`.  
  - Отвечает за отображение состояния и запуск действий пользователя.

- **Domain слой**  
  - Интерфейсы и модели: `CallHistoryStore`, `PendingCallStore`, `AppReadinessProvider`, `CallHistoryItem`, `PendingCall` и др.  
  - Бизнес‑правила: статусы звонков, источники действий (`ActionSource`), политики таймаутов, idempotency.

- **Data слой**  
  - Реализации репозиториев и менеджеры:  
    - `CallHistoryRepository` / `CallHistoryStore` (история звонков),  
    - `PendingCallManager` (очередь незавершённых звонков),  
    - `CallLogCorrelator`, `CallLogObserverManager` (сопоставление CallLog с командами/ручными звонками),  
    - `QueueManager` (очередь запросов к серверу),  
    - `ApiClient`, `TokenManager` (работа с REST и токенами).
  - Работа с сетью, базой данных (Room), преференсами и файловой системой.

---

## DI и точка входа

- **Точка входа приложения**: `CRMApplication` (подразумевается стандартный `Application` класс).
- **Service Locator / DI‑контейнер**: `AppContainer`:
  - создаёт и хранит одиночки (`ApiClient`, `TokenManager`, `QueueManager`, `CallHistoryStore`, `PendingCallStore`, `DiagnosticsPanel` и т.д.);
  - отдаёт зависимости в UI и сервисы.
- **Особенности**:
  - тяжёлые зависимости инициализируются отложенно на `Dispatchers.IO`, чтобы не блокировать main‑поток;
  - в debug‑режиме включён `StrictMode` для отлова случайного I/O в UI.

---

## Фоновая служба CallListenerService

Ключевой компонент, который обеспечивает связь с CRM и работу в фоне.

**Роль:**
- держит foreground‑сервис с уведомлением, чтобы ОС не убивала процесс;
- выполняет long‑poll / adaptive polling к CRM;
- переключает режимы опроса: `LONG_POLL`, `BURST`, `SLOW`;
- обрабатывает 429‑rate‑limit и сетевые ошибки (backoff);
- инициирует команды (вызывает системную звонилку);
- триггерит отправку телеметрии и логов.

**Основные элементы логики:**
- **Режимы работы:**
  - `LONG_POLL` — обычный режим долгого запроса (сервер держит соединение, пока нет команд).
  - `BURST` — короткие частые запросы (например, после открытия приложения или получения push).
  - `SLOW` — редкие запросы при проблемах сети или после бурста.
- **Защита от перегрузки сервера:**
  - жёсткий лимит циклов в `BURST` (hard cap),
  - cooldown между burst‑сессиями,
  - учёт времени в backoff и количества 429.
- **Уведомление foreground:**
  - показывает текущий режим работы и статус,
  - имеет action «Открыть приложение».

---

## Поток обработки команды звонка

Упрощённый поток из точки зрения сервера и клиента:

1. **CRM создаёт команду звонка** для оператора (номер, идентификатор, метаданные).
2. **Android‑клиент (CallListenerService)** выполняет `pullCall`:
   - `GET /api/phone/calls/pull/?device_id=...&wait_seconds=...`
   - сервер либо держит соединение, либо возвращает команду.
3. При получении команды:
   - событие логируется в метриках (`PullCallMetrics`, `DiagnosticsMetricsBuffer`);
   - создаётся запись в `PendingCallStore` с `actionSource = CRM_UI` (или иным источником);
   - формируется уведомление/инструкция для пользователя.
4. **Инициация звонка**:
   - приложение открывает системную звонилку с номером из команды;
   - создаётся `CallHistoryItem` со статусом `PENDING`/`UNKNOWN` и ссылкой на `callRequestId`.
5. **Отслеживание результата**:
   - `CallLogObserverManager` наблюдает за журналом звонков;
   - `CallLogCorrelator` сопоставляет запись журнала с конкретной командой/ручным звонком по номеру, направлению, времени (с учётом окна и idempotency key).
6. **Формирование финального статуса**:
   - статусы: `CONNECTED`, `NO_ANSWER`, `REJECTED`, `NO_ACTION`, `UNKNOWN`;
   - данные о длительности, направлении, источнике (`ActionSource`) записываются в историю.
7. **Отправка в CRM**:
   - `ApiClient.updateCall()` вызывает `POST /api/phone/calls/update/` с результатом;
   - телеметрия и логи при необходимости отправляются через `flushTelemetry()`.

---

## Ручные звонки (DialerFragment) и ActionSource

Помимо команд из CRM, приложение поддерживает **ручные звонки**:

- Пользователь набирает номер во вкладке `Телефон` (`DialerFragment`) и нажимает «Позвонить».
- Приложение:
  - создаёт `CallHistoryItem` и `PendingCall` с `actionSource = MANUAL`;
  - открывает системную звонилку;
  - отслеживает результат через `CallLogObserverManager` так же, как для автоматических звонков.
- В CRM отправляется статус с указанием `actionSource = "manual"`, что позволяет различать источники звонков в аналитике.

**Источники действий (`ActionSource`), по сути:**
- `CRM_UI` / `NOTIFICATION` / `HISTORY` — вызовы, инициированные CRM или через интерфейс истории;
- `MANUAL` — ручные звонки из вкладки телефона;
- другие значения возможны по мере расширения.

---

## Очередь запросов и оффлайн‑поведение

Для устойчивости к временным сбоям сети приложение использует очередь.

- **`QueueManager`**:
  - хранит в Room‑БД локальную очередь запросов (например, неотправленные телеметрические события);
  - гарантирует запись в БД перед «успехом» операции (idempotent поведение).
- **`ApiClient` и `LogSender`**:
  - отправляют события и логи на сервер;
  - при ошибке сети/серверной ошибке операции могут быть отложены в очередь.
- **Flush телеметрии**:
  - `flushTelemetry()` вызывается в ключевых точках (результат звонка, 429, logout и т.д.);
  - цель — минимизировать лаг между событием и попаданием данных в CRM.

---

## Токены и безопасность

- **`TokenManager`**:
  - хранит access/refresh токены (через `EncryptedSharedPreferences`, с fallback на обычные prefs при необходимости);
  - отслеживает время последнего успешного refresh и количество неудачных попыток;
  - реализует аккуратную стратегию очистки токенов, чтобы не разлогинивать пользователя при кратковременных проблемах сети.

- **`AuthInterceptor`**:
  - добавляет `Authorization: Bearer ...` ко всем защищённым запросам;
  - при 401/403 не очищает токены напрямую, а полагается на `TokenManager.refreshToken()`.

- **Логирование**:
  - все чувствительные данные в логах маскируются (токены, номера телефонов, device_id и т.п.);
  - в release‑сборках шумные уровни логов (DEBUG/VERBOSE) отключены.

---

## Диагностика и метрики

Диагностика — важная часть архитектуры, т.к. приложение должно предсказуемо работать на разных OEM‑устройствах.

- **`DiagnosticsPanel` и `DiagnosticsMetricsBuffer`**:
  - собирают метрики по режимам `LONG_POLL`/`BURST`/`SLOW`,
  - хранят кольцевой буфер диагностических событий (последние ~50),
  - формируют текстовый отчёт для поддержки (через hidden dev‑mode: 7 тапов по версии + long press).

- **`PullCallMetrics`**:
  - считает средние задержки доставки команд,
  - учитывает количество 429 за час,
  - считает время, проведённое в backoff.

Подробное описание полей диагностического отчёта см. в `guides/DIAGNOSTICS_GUIDE.md`.

---

## Навигация и UI‑слой

На момент актуальной версии UI‑слой построен по схеме:

- **Single‑Activity**:
  - `MainActivity` управляет `BottomNavigationView` и переключает фрагменты.

- **Фрагменты**:
  - `HomeFragment` — статус готовности, сводка за сегодня, быстрый доступ к фиксам;
  - `DialerFragment` — ручной набор номера с автоформатом `+7 (XXX) XXX‑XX‑XX`;
  - `HistoryFragment` — история звонков с поиском, бейджами источников, bottom‑sheet деталями;
  - `SettingsFragment` — авторизация, разрешения, инструкции OEM, диагностика, версия.

Подробности по UX и мотивам изменений — в `summaries/UI_UX_REVOLUTION_REPORT.md`.

---

## Как использовать этот документ

- **Новый разработчик**: прочитать этот файл целиком, затем перейти к `API_INTEGRATION.md` и `FEATURES.md`.
- **Архитектор / тимлид**: использовать как карту слоёв и компонентов при планировании новых фич и рефакторинга.
- **Поддержка**: сочетать с `guides/DIAGNOSTICS_GUIDE.md` и `plans/TORTURE_TEST_PLAN.md` для расследования проблем.

