# Отчёт: Исправление почтового сервиса рассылок

## 1. Карта текущей логики (как было)

### Проблемы в исходной реализации:

1. **Неконсистентные статусы**: Кампании переключались между PROCESSING и PENDING без фиксации причин и времени возобновления
2. **Отсутствие единого источника правды**: Причины пауз вычислялись в разных местах (tasks.py, views.py), что приводило к рассинхронизации
3. **Неточный rate limiting**: Использовался только SendLog для подсчета, что не гарантировало атомарность
4. **Неточный учет квоты**: Не учитывались локальные отправки после последнего sync с API
5. **Отсутствие защиты от гонок**: Недостаточная защита от параллельной обработки одних и тех же писем
6. **Некорректное завершение**: Кампании с failed получателями помечались как SENT

### Архитектура до исправлений:

```
send_pending_emails (Celery task)
  ├─ Проверка лимитов (SendLog.count)
  ├─ Прямое обновление CampaignQueue (без defer_queue)
  ├─ Нет атомарного rate limiting
  └─ Причины пауз вычисляются в views.py

mail_progress_poll (API endpoint)
  ├─ Вычисляет причины пауз самостоятельно
  ├─ Не использует CampaignQueue.defer_reason
  └─ Нет информации об очереди
```

## 2. Список найденных проблем

### Критические:

1. **Race conditions**: Несколько воркеров могли взять одни и те же письма
2. **Дребезг PROCESSING↔PENDING**: Кампании переключались без deferred_until
3. **Ложные уведомления**: Причины пауз вычислялись неправильно
4. **Неточный rate limiting**: SendLog.count не атомарен, возможны превышения лимита

### Важные:

5. **Неточный учет квоты**: emails_available не учитывал локальные отправки
6. **Неконсистентные статусы**: Кампании с failed помечались как SENT
7. **Отсутствие информации об очереди**: UI не показывал, сколько кампаний в очереди

### Потенциальные:

8. **Отсутствие защиты от дублей**: При сбое после отправки письмо могло быть отправлено повторно
9. **Нет информации о следующей кампании**: Менеджер не знает, когда начнется следующая рассылка

## 3. Схема новой логики

### Очередь и статусы:

```
CampaignQueue.status:
  PENDING → PROCESSING → COMPLETED
           ↓ (defer)
         PENDING (с deferred_until и defer_reason)

Причины отложения (defer_reason):
  - daily_limit: Дневной лимит пользователя
  - quota_exhausted: Квота smtp.bz исчерпана
  - outside_hours: Вне рабочего времени
  - rate_per_hour: Лимит в час достигнут
```

### Единый источник правды:

```
CampaignQueue
  ├─ defer_reason (причина паузы)
  ├─ deferred_until (время возобновления)
  └─ status (PENDING/PROCESSING/COMPLETED)

mail_progress_poll
  └─ Берет reason_code и next_run_at из CampaignQueue
```

### Rate limiting:

```
Redis (mailer:rate:hour:YYYY-MM-DD:HH)
  ├─ Атомарный INCR для подсчета
  ├─ TTL = 2 часа (запас)
  └─ Проверка перед отправкой каждого письма
```

### Учет квоты:

```
effective_quota = SmtpBzQuota.emails_available - local_sent_since_sync

local_sent_since_sync = SendLog.objects.filter(
    provider="smtp_global",
    status="sent",
    created_at__gte=quota.last_synced_at
).count()
```

### Защита от гонок:

```
1. Redis lock (mailer:send_pending_emails:lock)
2. select_for_update(skip_locked=True) при взятии кампании
3. select_for_update при взятии батча получателей
4. Атомарный Redis INCR для rate limiting
```

## 4. Список изменённых файлов

### Новые файлы:

1. **backend/mailer/services/__init__.py** - Инициализация модуля services
2. **backend/mailer/services/queue.py** - Сервис для отложения кампаний
   - `defer_queue()`: Единая функция для отложения с фиксацией причины и времени
3. **backend/mailer/services/rate_limiter.py** - Сервис для rate limiting
   - `check_rate_limit_per_hour()`: Проверка лимита через Redis
   - `increment_rate_limit_per_hour()`: Атомарное увеличение счетчика
   - `get_effective_quota_available()`: Эффективная квота с учетом локальных отправок

### Изменённые файлы:

4. **backend/mailer/tasks.py** - Основная логика отправки
   - Добавлены импорты новых сервисов
   - Использование `defer_queue()` для всех причин паузы
   - Использование Redis rate limiter вместо SendLog.count
   - Использование `get_effective_quota_available()` для точного учета квоты
   - Улучшена логика завершения кампании (учет failed)
   - Усилена защита от гонок (select_for_update)

5. **backend/mailer/views.py** - API endpoints
   - Переписан `mail_progress_poll()`:
     - reason_code и next_run_at берутся из CampaignQueue
     - Добавлены active_campaign, queued_count, next_campaign_at

6. **backend/mailer/tests.py** - Тесты
   - Добавлены тесты для defer_queue (rate_per_hour, quota_exhausted)
   - Добавлены тесты для poll endpoint
   - Добавлены тесты для защиты от гонок
   - Добавлены тесты для завершения кампании с failed
   - Добавлены тесты для rate limiter

## 5. Как проверить руками (чеклист)

### Проверка rate limiting (100 писем/час):

1. Создать кампанию с 150 получателями
2. Запустить рассылку
3. Проверить, что после 100 писем кампания откладывается
4. Проверить CampaignQueue: defer_reason = "rate_per_hour", deferred_until = начало следующего часа
5. Проверить poll endpoint: reason_code = "rate_per_hour", next_run_at указан

### Проверка дневного лимита:

1. Создать кампанию с получателями
2. Отправить 100 писем (достичь дневного лимита)
3. Проверить, что кампания откладывается до следующего дня
4. Проверить CampaignQueue: defer_reason = "daily_limit", deferred_until = завтра 09:00
5. Проверить poll endpoint: reason_code = "daily_limit"

### Проверка квоты:

1. Установить emails_available = 0 в SmtpBzQuota
2. Создать кампанию с получателями
3. Запустить рассылку
4. Проверить, что кампания откладывается
5. Проверить CampaignQueue: defer_reason = "quota_exhausted"

### Проверка защиты от гонок:

1. Запустить два celery worker одновременно
2. Создать кампанию с получателями
3. Проверить, что каждое письмо отправлено только один раз
4. Проверить, что нет дублей в SendLog

### Проверка poll endpoint:

1. Создать несколько кампаний в очереди
2. Вызвать `/mail/progress/poll/`
3. Проверить, что:
   - active_campaign показывает активную кампанию
   - queued_count показывает количество в очереди
   - next_campaign_at показывает время следующей кампании
   - reason_code и next_run_at берутся из CampaignQueue

### Проверка завершения с failed:

1. Создать кампанию с получателями
2. Имитировать ошибки отправки для части получателей
3. Завершить кампанию
4. Проверить, что кампания остается в SENDING (не переходит в SENT)
5. Проверить, что failed получатели видны в UI

## 6. КРАТКОЕ РЕЗЮМЕ

Почтовый сервис рассылок переработан для обеспечения стабильности и предсказуемости. Основные изменения:

**Архитектурные улучшения:**
- Создан единый сервис `defer_queue()` для отложения кампаний с фиксацией причин
- CampaignQueue стал единым источником правды о причинах пауз
- Добавлен атомарный Redis rate limiter для строгого контроля 100 писем/час
- Улучшен учет квоты с учетом локальных отправок

**Исправления проблем:**
- Устранены race conditions через Redis lock и select_for_update
- Устранен дребезг PROCESSING↔PENDING через обязательный deferred_until
- Исправлены ложные уведомления через единый источник правды
- Исправлено некорректное завершение кампаний с failed получателями

**Улучшения UX:**
- Poll endpoint показывает активную кампанию, количество в очереди и время следующей кампании
- Причины пауз и время возобновления берутся из CampaignQueue (единый источник правды)

**Тесты:**
- Добавлены тесты для всех критических сценариев
- Покрыты: defer при лимитах, защита от гонок, завершение с failed, rate limiting

Система теперь работает стабильно, причины остановок понятны менеджерам, поведение предсказуемо.
