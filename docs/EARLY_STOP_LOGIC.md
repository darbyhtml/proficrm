# Логика раннего прерывания пагинации контактов

## Как это работает сейчас

### Текущий алгоритм:

1. **Запрос контактов**: API возвращает контакты страницами по 250 штук
2. **После каждой страницы**: Вызывается callback `should_stop_pagination` с **всеми накопленными контактами**
3. **Проверка**: Callback проверяет последние 250 контактов (текущая страница) и обновляет `found_company_ids_during_pagination`
4. **Условия прерывания**:
   - **Условие 1**: Найдены контакты для **ВСЕХ 50 компаний** (100%) И получено >= 100 контактов
   - **Условие 2**: Получено >= 2000 контактов И найдено для **80%+ компаний**

### Примеры:

#### Пример 1: Найдено 10 контактов для всех 50 компаний
- Получено: 250 контактов (1 страница)
- Найдено для: 50/50 компаний (100%)
- **Результат**: ✅ Прервется после 1-й страницы (условие 1 выполнено)

#### Пример 2: Найдено 10 контактов для 3 компаний из 50
- Получено: 25000 контактов (100 страниц)
- Найдено для: 3/50 компаний (6%)
- **Результат**: ❌ НЕ прервется (6% < 80%, условие 2 не выполнено)

#### Пример 3: Найдено контакты для 40 компаний из 50 (80%)
- Получено: 2000 контактов (8 страниц)
- Найдено для: 40/50 компаний (80%)
- **Результат**: ✅ Прервется после 8-й страницы (условие 2 выполнено)

## Проблемы текущей логики

### 1. Проверка только последних 250 контактов
```python
for contact in current_contacts[-250:]:  # ❌ Проверяет только последние 250
```
**Проблема**: Если контакты для компаний были на первых страницах, они не учитываются при проверке.

**Решение**: Проверять **все накопленные контакты**, а не только последние 250.

### 2. Не учитывает количество контактов на компанию
**Проблема**: Логика не различает, что для одной компании может быть 1 контакт, а для другой - 10.

**Текущее поведение**: Прерывает, если нашел **хотя бы один** контакт для каждой компании.

**Вопрос пользователя**: "Если для следующей компании будет 16 контактов?"

**Ответ**: Текущая логика **не подстраивается** под количество контактов. Она проверяет только факт наличия контакта для компании, а не их количество.

## Предложения по улучшению

### Вариант 1: Улучшенная проверка (проверять все контакты)
```python
def should_stop_pagination(current_contacts: list[dict]) -> bool:
    # Проверяем ВСЕ накопленные контакты, а не только последние 250
    for contact in current_contacts:  # ✅ Все контакты
        # ... проверка принадлежности к компаниям ...
    
    # Прерываем, если нашли контакты для всех компаний
    if len(current_contacts) >= 100 and len(found_company_ids_during_pagination) == len(batch_company_ids_set):
        return True
```

### Вариант 2: Адаптивная логика (учитывать количество контактов)
```python
def should_stop_pagination(current_contacts: list[dict]) -> bool:
    # Подсчитываем количество контактов для каждой компании
    contacts_per_company: dict[int, int] = {}
    for contact in current_contacts:
        # ... находим company_id ...
        if company_id:
            contacts_per_company[company_id] = contacts_per_company.get(company_id, 0) + 1
    
    # Прерываем, если:
    # 1. Нашли контакты для всех компаний
    # 2. ИЛИ получили много контактов (2000+) и нашли для большинства (80%+)
    # 3. И среднее количество контактов на компанию >= 1
    if len(found_company_ids_during_pagination) == len(batch_company_ids_set):
        avg_contacts = sum(contacts_per_company.values()) / len(contacts_per_company) if contacts_per_company else 0
        if avg_contacts >= 1:  # Хотя бы 1 контакт на компанию в среднем
            return True
```

### Вариант 3: Прерывание по лимиту контактов
```python
def should_stop_pagination(current_contacts: list[dict]) -> bool:
    # Прерываем, если получили слишком много контактов (5000+)
    # Это означает, что API возвращает все контакты, а не только для наших компаний
    if len(current_contacts) >= 5000:
        # Проверяем, сколько из них действительно для наших компаний
        found_count = len([c for c in current_contacts if _is_contact_for_our_companies(c)])
        if found_count / len(current_contacts) < 0.1:  # Меньше 10% релевантных
            logger.warning("Получено слишком много нерелевантных контактов, прерываем пагинацию")
            return True
```

## Рекомендация

**Использовать Вариант 1 + Вариант 3**:
1. Проверять **все накопленные контакты** (не только последние 250)
2. Прерывать, если получили слишком много нерелевантных контактов (5000+ и < 10% релевантных)

Это даст максимальный эффект ускорения при сохранении надежности.
