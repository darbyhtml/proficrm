# Magic Link Authentication — Архитектура

**Дата создания:** 2024-01-XX  
**Версия:** 1.0

---

## 1. Общее описание

Система входа в CRM только по одноразовым ссылкам, генерируемым администратором. Парольный вход отключается (опционально, через настройку).

---

## 2. Модель MagicLinkToken

**Файл:** `backend/accounts/models.py`

**Поля:**
- `user` (ForeignKey на User) — пользователь, для которого создан токен
- `token_hash` (CharField, max_length=64) — SHA256 хэш токена (хранится только хэш)
- `created_at` (DateTimeField, auto_now_add=True) — время создания
- `expires_at` (DateTimeField) — время истечения (created_at + 30 минут)
- `used_at` (DateTimeField, nullable) — время использования (null = не использован)
- `created_by` (ForeignKey на User) — администратор, создавший токен
- `ip_address` (GenericIPAddressField, nullable) — IP адрес при использовании (для аудита)
- `user_agent` (CharField, max_length=255, nullable) — User-Agent при использовании (для аудита)

**Индексы:**
- `token_hash` (unique=True) — для быстрого поиска
- `user`, `expires_at`, `used_at` — для очистки истёкших токенов

**Методы:**
- `is_valid()` — проверка: не истёк и не использован
- `mark_as_used(ip, user_agent)` — пометить как использованный

---

## 3. Endpoints

### 3.1. Генерация токена (только для админа)

**URL:** `POST /settings/users/<user_id>/magic-link/generate/`  
**View:** `settings_user_magic_link_generate()` в `backend/ui/views.py`

**Требования:**
- Пользователь должен быть администратором (`require_admin()`)
- Целевой пользователь должен существовать и быть активным

**Логика:**
1. Генерируется случайный токен (32 байта, hex)
2. Вычисляется SHA256 хэш
3. Создаётся запись `MagicLinkToken` с `expires_at = now + 30 минут`
4. Возвращается полная ссылка для входа

**Ответ:**
```json
{
  "token": "abc123...",
  "link": "http://example.com/auth/magic/abc123.../",
  "expires_at": "2024-01-XX 12:30:00"
}
```

**Безопасность:**
- Rate limiting: не чаще 1 раза в 10 секунд на пользователя
- Логирование: кто создал, для кого, когда

### 3.2. Вход по токену

**URL:** `GET /auth/magic/<token>/`  
**View:** `magic_link_login()` в `backend/accounts/views.py`

**Логика:**
1. Вычисляется SHA256 хэш токена
2. Ищется `MagicLinkToken` по хэшу
3. Проверка: существует, не истёк (`expires_at > now`), не использован (`used_at is None`)
4. Если валиден:
   - Создаётся Django сессия для пользователя
   - Токен помечается как использованный (`used_at = now`, сохраняются IP и User-Agent)
   - Логируется успешный вход
   - Редирект в кабинет (`/`)
5. Если невалиден:
   - Показывается ошибка
   - Логируется неудачная попытка

**Безопасность:**
- Rate limiting: не чаще 5 попыток в минуту с одного IP
- Защита от перебора токенов
- Одноразовость (после использования токен недействителен)

---

## 4. UI для администратора

### 4.1. Страница редактирования пользователя

**Файл:** `backend/templates/ui/settings/user_form.html`

**Добавить:**
- Кнопка "Сгенерировать ссылку входа"
- Модальное окно или секция с:
  - Ссылкой (отображается один раз)
  - Кнопкой "Скопировать"
  - Статусом: активна/истекла/использована
  - Временем истечения

### 4.2. Список пользователей

**Файл:** `backend/templates/ui/settings/users.html`

**Добавить (опционально):**
- Колонка "Последняя ссылка" с датой создания последнего токена
- Статус последнего токена (активна/истекла/использована)

---

## 5. Отключение password login

**Вариант A (рекомендуется):** Оставить форму, но всегда показывать сообщение "Вход только по ссылке"

**Вариант B:** Полностью убрать форму пароля

**Выбран вариант A** для минимальных рисков для существующих сессий.

**Реализация:**
- В `SecureLoginView.post()` проверять настройку `MAGIC_LINK_ONLY`
- Если включено → всегда возвращать ошибку "Вход только по одноразовой ссылке"
- Форма остаётся, но пароль не принимается

**Настройка:**
- Переменная окружения `MAGIC_LINK_ONLY=1` (опционально)
- Или через Django settings (по умолчанию False)

---

## 6. Аннулирование паролей

**При включении режима "magic link only":**
- Для всех пользователей (кроме супер-админа и сервисных учёток) установить `set_unusable_password()`
- Логины остаются (для идентификации)

**Исключения:**
- Супер-админ (`is_superuser=True`) — пароль не аннулируется (для экстренного доступа)
- Сервисные учётки (если есть) — определяются по специальному флагу или роли

**Команда управления:**
```bash
python manage.py accounts_annul_passwords --dry-run  # предпросмотр
python manage.py accounts_annul_passwords  # выполнение
```

---

## 7. Безопасность

### 7.1. Генерация токена

- Использовать `secrets.token_urlsafe(32)` для генерации
- Хранить только SHA256 хэш в БД
- Токен передаётся только один раз (при генерации)

### 7.2. Rate limiting

- Генерация: не чаще 1 раза в 10 секунд на пользователя
- Использование: не чаще 5 попыток в минуту с одного IP

### 7.3. Аудит

- Логирование: кто создал токен, для кого, когда
- Логирование: кто вошёл по токену, когда, с какого IP
- Хранение IP и User-Agent при использовании токена

### 7.4. Защита от перебора

- Токен только в URL (не в POST)
- Длинный токен (32 байта = 256 бит энтропии)
- Rate limiting на использование

---

## 8. Очистка истёкших токенов

**Celery задача:**
- Периодически (раз в час) удалять токены, где `expires_at < now` или `used_at is not None`

**Management command:**
```bash
python manage.py cleanup_expired_magic_links
```

---

## 9. Тестирование

### 9.1. Unit тесты

**Файл:** `backend/accounts/tests_magic_link.py`

**Тесты:**
- ✅ Генерация токена (админ может, не админ не может)
- ✅ Токен валиден до истечения
- ✅ Токен невалиден после истечения
- ✅ Токен невалиден после использования
- ✅ Одноразовость (повторное использование не работает)
- ✅ Вход создаёт сессию
- ✅ Rate limiting на генерацию
- ✅ Rate limiting на использование
- ✅ Логирование успешного входа
- ✅ Логирование неудачной попытки

### 9.2. Integration тесты

- ✅ Полный flow: генерация → использование → вход
- ✅ Попытка использовать истёкший токен
- ✅ Попытка использовать использованный токен

---

## 10. Миграции

**Файл:** `backend/accounts/migrations/XXXX_add_magic_link_token.py`

**Операции:**
- Создание модели `MagicLinkToken`
- Индексы на `token_hash`, `user`, `expires_at`, `used_at`

---

## 11. Rollback план

**Если нужно вернуть password login:**

1. Установить `MAGIC_LINK_ONLY=0` в env
2. Перезапустить сервер
3. Пользователи смогут войти по паролю (если пароли не были аннулированы)

**Если пароли были аннулированы:**
- Нужно сбросить пароли через Django admin или management command
- Или создать новые пароли для пользователей

**Команда для восстановления паролей:**
```bash
python manage.py accounts_reset_passwords --user-id=123 --password=newpass123
```

---

## 12. Риски

1. **Потеря доступа:** Если админ заблокирован, некому создать ссылку
   - **Митигация:** Супер-админ всегда может войти по паролю (если не аннулирован)

2. **Утечка токена:** Если токен перехвачен, злоумышленник может войти
   - **Митигация:** Одноразовость, короткий TTL (30 минут), rate limiting

3. **Регрессия:** Существующие сессии могут быть нарушены
   - **Митигация:** Вариант A (форма остаётся, но показывает сообщение) минимизирует риски

---

## 13. Изменения в коде

### 13.1. Backend

1. `backend/accounts/models.py` — модель `MagicLinkToken`
2. `backend/accounts/views.py` — endpoint входа по токену
3. `backend/ui/views.py` — endpoint генерации токена
4. `backend/accounts/management/commands/` — команды для управления паролями
5. `backend/crm/settings.py` — настройка `MAGIC_LINK_ONLY`

### 13.2. Frontend

1. `backend/templates/ui/settings/user_form.html` — UI генерации ссылки
2. `backend/templates/registration/login.html` — сообщение о входе только по ссылке

---

## 14. Следующие шаги

1. Создать модель `MagicLinkToken`
2. Создать миграцию
3. Создать endpoints (генерация, вход)
4. Обновить UI
5. Добавить отключение password login (опционально)
6. Написать тесты
7. Создать management commands
