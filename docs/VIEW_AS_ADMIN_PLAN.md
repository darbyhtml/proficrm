# План: идеальная работа «Режима просмотра администратора»

Режим позволяет администратору смотреть CRM от лица другой роли, филиала или конкретного пользователя (только отображение и фильтры, права не меняются).

---

## 1. Критические баги (исправить в первую очередь)

### 1.1 ✅ Имя параметра филиала в форме (ИСПРАВЛЕНО)
- **Файл:** `backend/ui/views.py`, `view_as_update`
- **Проблема:** Форма в шапке (`base.html`) отправляет `view_as_branch_id`, а view читал `view_branch_id` — выбор филиала в выпадающем списке не сохранялся.
- **Решение:** Читать оба варианта: `request.POST.get("view_as_branch_id") or request.POST.get("view_branch_id")`.

### 1.2 Баннер: филиал «все» при выборе только роли
- **Файл:** `backend/ui/context_processors.py`
- **Проблема:** Когда включён view_as и выбрана только роль (без филиала), `view_as_branch` остаётся равным филиалу реального админа (из начального присваивания), и в баннере показывается не «все», а филиал админа.
- **Решение:** В блоке `else` (когда не выбран конкретный пользователь), если `as_branch_id` не задан в сессии, явно выставлять `view_as_branch = None`.

### 1.3 Баннер: показ «от лица пользователя»
- **Файл:** `backend/templates/ui/base.html`, баннер «Режим просмотра администратора»
- **Проблема:** При выборе конкретного пользователя баннер показывает только роль и филиал, но не имя пользователя.
- **Решение:** Если задан `view_as_user`, в баннере добавить текст вида «от лица: {{ view_as_user.get_full_name|default:view_as_user.username }}».

---

## 2. Backend: использование эффективного пользователя (view_as)

Сейчас во многих view используется `request.user`. Для корректной работы режима просмотра нужно везде, где данные фильтруются по пользователю/роли/филиалу, использовать **эффективного пользователя**: `get_effective_user(request)` (он возвращает выбранного в view_as пользователя или `request.user`).

### 2.1 Dashboard (`backend/ui/views.py`, `dashboard`)
- **Сейчас:** `user = request.user`, задачи по `assigned_to=user`, договоры по `responsible=user`, запросы на удаление по `user.branch_id`.
- **Нужно:** `user = get_effective_user(request)` в начале view; все запросы уже используют переменную `user`, после замены источник данных будет «от лица» выбранного пользователя/роли.
- **Важно:** Для «роль + филиал» без выбранного пользователя эффективный пользователь = реальный админ (get_effective_user возвращает только при выбранном view_as_user_id). Для фильтра по филиалу на дашборде уже используется `view_as_branch_id` (менеджеры по филиалу). Задачи и договоры на дашборде при «роль/филиал» без пользователя не переключаются — см. п. 4.1.

### 2.2 Dashboard poll и SSE (`dashboard_poll`, `dashboard_sse`)
- Аналогично: подставлять `user = get_effective_user(request)` и использовать его для фильтров задач/данных.

### 2.3 Список задач (`task_list`)
- **Сейчас:** `user = request.user`, `visible_tasks_qs(user)`, assignees и фильтр `mine` по `user`.
- **Нужно:** `user = get_effective_user(request)`; тогда видимость задач, список «Кому поставлена» и «мои» будут соответствовать выбранному в view_as пользователю (при выборе конкретного пользователя). При только «роль/филиал» без пользователя — оставить текущее поведение (эффективный пользователь = реальный).

### 2.4 Аналитика (`analytics`, `analytics_user`)
- **Сейчас:** `user = request.user`, список пользователей и филиал по `user.role` / `user.branch_id`.
- **Нужно:** `user = get_effective_user(request)` (или отдельно учитывать view_as_role/view_as_branch при отсутствии view_as_user), чтобы список «кого показываем» и фильтры соответствовали выбранной роли/филиалу/пользователю.

### 2.5 Список компаний (`company_list`, company_list_ajax)
- Уже учтены `view_as_branch_id` и `view_as_user` для фильтра по филиалу и кэш-ключа.
- **Дополнительно:** Передавать в контекст и в фильтры `responsibles` и `transfer_targets` от эффективного пользователя: `get_users_for_lists(get_effective_user(request))`, `get_transfer_targets(get_effective_user(request))`, чтобы выпадающие списки «Ответственный» и цели передачи соответствовали режиму просмотра.
- **Опционально:** При выбранном в view_as менеджере подставлять `default_responsible_id=effective_user.id` в `_apply_company_filters`, чтобы по умолчанию показывались «мои компании».

### 2.6 Другие view в `ui/views.py`
- Просмотр/редактирование компании, задачи, смена ответственного, массовые действия и т.д.: везде, где логика «может ли этот пользователь видеть/менять» должна совпадать с тем, что видит админ в режиме просмотра, использовать `get_effective_user(request)` для проверок и фильтров (например, списки исполнителей, назначения, ограничения по филиалу). При этом **на запись (создание/изменение/удаление)** всегда оставлять `request.user`, чтобы действия выполнялись от имени реального админа.

### 2.7 Mailer (`backend/mailer/views.py`)
- Список рассылок, настройки, квоты — фильтруются по `request.user`. Для единообразия с UI можно передавать в контекст «от чьего имени показываем» через `get_effective_user(request)` и использовать его только для отображения списков/фильтров, не для изменения настроек.

---

## 3. Шаблоны: визуальные права (view_*)

В шаблонах для **отображения** блоков (показывать/не показывать как у роли) нужно использовать переменные контекста `view_is_admin`, `view_can_view_activity`, `view_can_view_cold_call_reports`, а не `is_admin` / `can_view_activity` (реальные права).

### 3.1 Уже сделано
- **base.html:** пункт меню «Админка» показывается с учётом `view_as_enabled` и `view_is_admin`.

### 3.2 Нужно проверить/заменить
- **company_detail.html:** блоки с `{% if is_admin %}` (строки 604, 738, 1203 и т.д.) — если это «показывать кнопку/блок как для админа», заменить на `view_is_admin`; если «реальное право на действие» — оставить `is_admin`.
- **company_list.html:** кнопки/блоки «только для админа» (строка 23) — по смыслу: отображение как у роли → `view_is_admin`.
- **task_list.html:** блок с `is_admin` (строка 281) — по смыслу: показ как админу → `view_is_admin`.
- **dashboard.html:** блок с `can_view_cold_call_reports` (строка 55) — для отображения как у роли → `view_can_view_cold_call_reports` (уже передаётся из view; в шаблоне может использоваться переменная из контекста).
- **mail (campaigns, campaign_detail, settings, _campaign_row):** все `is_admin` для отображения списков/колонок/кнопок «как видит админ» → `view_is_admin`; для реального доступа к действиям — оставить проверки по реальному пользователю в view.
- **analytics_user.html:** `is_admin` (строки 105, 193) — отображение колонки/поля → `view_is_admin`.

Итог: везде, где решается «показывать ли этот блок в интерфейсе так, как его видит выбранная роль», использовать `view_*`; где решается «имеет ли текущий пользователь право на действие» — оставлять реальные права (и при необходимости проверять в view по `request.user`).

---

## 4. Логика «только роль/филиал» без выбранного пользователя

Сейчас `get_effective_user(request)` возвращает пользователя только если в сессии задан `view_as_user_id`. При выборе только «Роль» или «Филиал» (без «Пользователь») эффективный пользователь = реальный админ, поэтому:
- задачи, договоры, «мои» фильтры на дашборде и в списке задач остаются админскими;
- списки компаний и дашборд уже ограничиваются по `view_as_branch_id` и `view_as_role` там, где это заложено (компании по филиалу, менеджеры по филиалу на дашборде).

### 4.1 Опциональное расширение (сложнее)
- Ввести «виртуального пользователя» по паре (view_as_role, view_as_branch): при отсутствии view_as_user_id создавать объект с полями role/branch из сессии и передавать его в `visible_tasks_qs`, фильтры договоров и т.д. Требует аккуратной реализации (без сохранения в БД, только для чтения), чтобы не ломать безопасность. Можно вынести в отдельную задачу после выполнения п. 1–3.

---

## 5. Политика доступа (policy)

- **Сейчас:** `policy_can` и `policy_required` используют `request.user` (реальный пользователь). Доступ к страницам и действиям остаётся у реального админа — это правильно.
- **Меню:** видимость пунктов (Аналитика, Админка) уже скорректирована через `view_is_admin` / `view_as_enabled` в base.html. Дополнительно можно для пункта «Аналитика» использовать `view_can_view_activity` или аналог из view_*, если нужно скрывать аналитику при просмотре «как менеджер».

---

## 6. API (внешние и внутренние)

- **REST/другие API:** обычно аутентифицируются по токену и не имеют доступа к сессии Django. Режим просмотра завязан на сессию, поэтому для API он по умолчанию не применяется. Если понадобится «view_as» в API, нужно явно передавать параметр или заголовок и обрабатывать его в API (без изменения текущего плана).
- **Внутренние AJAX (например, company list, task list):** вызываются из браузера с той же сессией; view уже получают `request.session`, поэтому после внедрения `get_effective_user(request)` в соответствующие view поведение будет единым.

---

## 7. Тесты

- ✅ Добавлен файл `backend/ui/tests/test_view_as.py`:
  - `view_as_update`: только админ может вызывать; POST с `view_as_branch_id` сохраняет филиал в сессии; POST с `view_user_id` сохраняет пользователя; форма принимает параметр `view_as_branch_id`.
  - `view_as_reset`: очищает `view_as_user_id`, `view_as_role`, `view_as_branch_id` в сессии.
  - `settings_users`: при выключении режима (toggle off) очищаются все ключи view_as в сессии.
  - Контекст-процессор: при view_as с ролью без филиала в контексте `view_as_branch` = None.
- Опционально: тесты на dashboard/task_list/company_list с включённым view_as и выбранным пользователем (данные соответствуют выбранному пользователю) — при необходимости добавить при наличии рабочей тестовой БД.

**Запуск тестов (Docker):** из корня проекта (рядом с `docker-compose.yml`).

Если контейнер **web уже запущен** (`docker compose ps` показывает proficrm-web-1):
```bash
docker compose exec web python manage.py test
docker compose exec web python manage.py test ui.tests.test_view_as --verbosity=2
```
Если рабочая директория в контейнере не `backend`, укажите путь:  
`docker compose exec web sh -c "cd /app/backend && python manage.py test"`

Если контейнер не запущен (запуск нового контейнера):
```bash
docker compose run --rm web sh -c "pip install -q -r /app/backend/requirements.txt && python manage.py test"
./scripts/run_tests_docker.sh ui.tests.test_view_as
```
На Windows: `scripts\run_tests_docker.bat ui.tests.test_view_as`

---

## 8. Чек-лист по файлам

| Файл / зона | Действие |
|-------------|----------|
| `backend/ui/views.py` | view_as_update: читать `view_as_branch_id` (сделано). dashboard/dashboard_poll/dashboard_sse: user = get_effective_user(request). task_list: user = get_effective_user(request). analytics/analytics_user: user = get_effective_user(request). company_list: responsibles/transfer_targets от get_effective_user. |
| `backend/ui/context_processors.py` | При view_as без пользователя и без view_as_branch_id выставлять view_as_branch = None. |
| `backend/templates/ui/base.html` | Баннер: при view_as_user показывать «от лица: ФИО». Проверить пункт Аналитика по view_can_view_activity. |
| `backend/templates/ui/company_detail.html` | Заменить отображаемые проверки is_admin на view_is_admin где уместно. |
| `backend/templates/ui/company_list.html` | Аналогично is_admin → view_is_admin для отображения. |
| `backend/templates/ui/task_list.html` | is_admin → view_is_admin для отображения. |
| `backend/templates/ui/dashboard.html` | Использовать view_can_view_cold_call_reports для отображения блока. |
| `backend/templates/ui/mail/*.html` | is_admin → view_is_admin для отображения списков/кнопок. |
| `backend/templates/ui/analytics_user.html` | is_admin → view_is_admin для отображения. |
| `backend/mailer/views.py` | По желанию: контекст от get_effective_user для отображения списков. |
| Тесты | ✅ Добавлен `ui/tests/test_view_as.py` (форма филиала/пользователя, сброс, контекст). |

---

## 9. Порядок внедрения

1. Исправить баги (п. 1.2, 1.3) — контекст-процессор и баннер.
2. Ввести `get_effective_user` в dashboard, task_list, analytics, company_list (responsibles/transfer_targets).
3. Пройтись по шаблонам и заменить отображаемые проверки на view_* (п. 3.2).
4. Добавить тесты (п. 7).
5. Опционально: виртуальный пользователь для «роль+филиал» без выбранного пользователя (п. 4.1) и поддержка view_as в API при необходимости.

После этого режим просмотра администратора будет работать последовательно во всех ключевых экранах и списках.
